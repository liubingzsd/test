#include <stdio.h>   
#include <stdlib.h>   
#include <string.h>  
#include <malloc.h>
#include <math.h>   
#include "kd_tree.h"   

//计算平方的宏定义,相当于函数   
#define SQ(x)           ((x) * (x))   

static void clear_rec(kd_node_s *node, void(*destr)(void*));
static int insert_rec(kd_node_s **node, const float *pos, void *data, int dir, int dim);
static int rlist_insert(result_node_s *list, kd_node_s *item, float dist_sq);
static void clear_results(kd_result_s *set);

static kd_hyper_rect_s *hyperrect_create(int dim, const float *min, const float *max);
static void hyperrect_free(kd_hyper_rect_s *rect);
static kd_hyper_rect_s *hyperrect_duplicate(const kd_hyper_rect_s *rect);
static void hyperrect_extend(kd_hyper_rect_s *rect, const float *pos);
static float hyperrect_dist_sq(kd_hyper_rect_s *rect, const float *pos);

 
#define alloc_resnode()     malloc(sizeof(result_node_s))  
#define free_resnode(n)     free(n)   
 


//create kd_tree   
kd_tree_s *kd_create(int k)
{
	kd_tree_s *tree;
	tree = (kd_tree_s *)malloc(sizeof(*tree));
	if (!tree)
	{
		return 0;
	}
	tree->dim = k;
	tree->root = 0;
	tree->destr = 0;
	tree->rect = 0;
	return tree;
}

//free kdtree   
void kd_free(kd_tree_s *tree)
{
	if (tree) 
	{
		kd_clear(tree);
		free(tree);
	}
}

//清除掉超平面,是按节点递归地进行的   
static void clear_rec(kd_node_s *node, void(*destr)(void*))
{
	if (!node)
	{
		return;   //一个节点对应一个超平面 
	} 

	 //递归函数，递归地清除掉二叉树左分支的超平面和二叉树右分支的超平面   
	clear_rec(node->left, destr);
	clear_rec(node->right, destr);

	//如果data清楚函数不为空,就释放掉data   
	if (destr)
	{
		destr(node->data);
	}
	//释放节点的坐标数组   
	free(node->pos);
	//释放节点   
	free(node);
}

//kdtree清除   
void kd_clear(kd_tree_s *tree)
{
	//清除树中每个节点的超平面,释放树中的各个节点   
	clear_rec(tree->root, tree->destr);
	tree->root = 0;

	//如果树的超平面指针不为空,对其进行释放   
	if (tree->rect)
	{
		hyperrect_free(tree->rect);
		tree->rect = 0;
	}
}

//数据销毁，用一个外来的函数来进行data的销毁   
void kd_data_destructor(kd_tree_s *tree, void(*destr)(void*))
{
	//用外来的函数来执行kdtree的销毁函数   
	tree->destr = destr;
}


//在一个树节点位置处插入超矩形   
static int insert_rec(kd_node_s **nptr, const float *pos, void *data, int dir, int dim)
{
	int new_dir;
	kd_node_s *node;

	//如果这个节点是不存在的   
	if (!*nptr)
	{
		//分配一个结点   
		node = (kd_node_s *)malloc(sizeof(*node));
		if (!node)
		{
			return -1;
		}
		if (!(node->pos = (float*)malloc(dim * sizeof *node->pos))) {
			free(node);
			return -1;
		}
		memcpy(node->pos, pos, dim * sizeof *node->pos);
		node->data = data;
		node->dir = dir;
		node->left = node->right = 0;
		*nptr = node;
		return 0;
	}

	node = *nptr;
	new_dir = (node->dir + 1) % dim;
	if (pos[node->dir] < node->pos[node->dir])
	{
		return insert_rec(&(*nptr)->left, pos, data, new_dir, dim);
	}
	return insert_rec(&(*nptr)->right, pos, data, new_dir, dim);
}

//节点插入操作   
//参数为:要进行插入操作的kdtree,要插入的节点坐标,要插入的节点的数据   
int kd_insert(kd_tree_s *tree, const float *pos, void *data)
{
	//插入超矩形   
	if (insert_rec(&tree->root, pos, data, 0, tree->dim))
	{
		return -1;
	}
	//如果树还没有超矩形,就创建一个超矩形   
	//如果已经有了超矩形,就扩展原有的超矩形   
	if (tree->rect == 0)
	{
		tree->rect = hyperrect_create(tree->dim, pos, pos);
	}
	else
	{
		hyperrect_extend(tree->rect, pos);
	}

	return 0;
}

//插入float型坐标的节点   
//参数为:要进行插入操作的kdtree,要插入的节点坐标,要插入的节点的数据   
//将float型的坐标赋值给float型的缓冲区,经过这个类型转化后进行插入   
//本质上是一种类型转化   
int kd_insertf(kd_tree_s *tree, const float *pos, void *data)
{
	static float sbuf[16];
	float *bptr, *buf = 0;
	int res, dim = tree->dim;

	//如果kdtree的维数大于16, 分配dim维float类型的数组   
	if (dim > 16)
	{
#ifndef NO_ALLOCA   
		if (dim <= 256)
			bptr = buf = (float*)alloca(dim * sizeof *bptr);
		else
#endif   
			if (!(bptr = buf = (float*)malloc(dim * sizeof *bptr)))
			{
				return -1;
			}
	}
	//如果kdtree的维数小于16, 直接将指针指向已分配的内存   
	else
	{
		bptr = buf = sbuf;
	}

	//将要插入点的位置坐标赋值给分配的数组   
	while (dim-- > 0)
	{
		*bptr++ = *pos++;
	}

	//调用节点插入函数kd_insert   
	res = kd_insert(tree, buf, data);
#ifndef NO_ALLOCA   
	if (tree->dim > 256)
#else   
	if (tree->dim > 16)
#endif   
		//释放缓存   
		free(buf);
	return res;
}

//给出三维坐标值的三维kdtree插入   
int kd_insert3(kd_tree_s *tree, float x, float y, float z, void *data)
{
	float buf[3];
	buf[0] = x;
	buf[1] = y;
	buf[2] = z;
	return kd_insert(tree, buf, data);
}

//给出三维float型坐标值的三维kdtree插入   
int kd_insert3f(kd_tree_s *tree, float x, float y, float z, void *data)
{
	float buf[3];
	buf[0] = x;
	buf[1] = y;
	buf[2] = z;
	return kd_insert(tree, buf, data);
}

//找到最近邻的点   
//参数为:树节点指针, 位置坐标, 阈值, 返回结果的节点, bool型排序,维度   
static int find_nearest(kd_node_s *node, const float *pos, float range, result_node_s *list, int ordered, int dim)
{
	float dist_sq, dx;
	int i, ret, added_res = 0;

	if (!node) return 0;  //注意这个地方,当节点为空的时候,表明已经查找到最终的叶子结点,返回值为零  

	dist_sq = 0;
	//计算两个节点间的平方和   
	for (i = 0; i<dim; i++)
	{
		dist_sq += SQ(node->pos[i] - pos[i]);
	}
	//如果距离在阈值范围内,就将其插入到返回结果链表中   
	if (dist_sq <= SQ(range))
	{
		if (rlist_insert(list, node, ordered ? dist_sq : -1.0) == -1)
		{
			return -1;
		}
		added_res = 1;
	}

	//在这个节点的划分方向上,求两者之间的差值   
	dx = pos[node->dir] - node->pos[node->dir];

	//根据这个差值的符号, 选择进行递归查找的分支方向   
	ret = find_nearest(dx <= 0.0 ? node->left : node->right, pos, range, list, ordered, dim);
	//如果返回的值大于等于零,表明在这个分支中有满足条件的节点,则返回结果的个数进行累加,并在节点的另一个方向进行查找最近的节点  
	if (ret >= 0 && fabs(dx) < range)
	{
		added_res += ret;
		ret = find_nearest(dx <= 0.0 ? node->right : node->left, pos, range, list, ordered, dim);
	}
	if (ret == -1)
	{
		return -1;
	}
	added_res += ret;

	return added_res;
}


//找到最近邻的n个节点   
#if 0   
static int find_nearest_n(struct kdnode *node, const float *pos, float range, int num, struct rheap *heap, int dim)
{
	float dist_sq, dx;
	int i, ret, added_res = 0;

	if (!node) return 0;

	/* if the photon is close enough, add it to the result heap */
	//如果足够近就将其加入到结果堆中   
	dist_sq = 0;
	//计算两者间的欧式距离   
	for (i = 0; i<dim; i++)
	{
		dist_sq += SQ(node->pos[i] - pos[i]);
	}
	//如果计算所得距离小于阈值   
	if (dist_sq <= range_sq) {
		//如果堆的大小大于num,也就是大于总的要找的节点数   
		if (heap->size >= num)
		{
			/* get furthest element */
			//得到最远的节点   
			struct res_node *maxelem = rheap_get_max(heap);

			/* and check if the new one is closer than that */
			//测试这个节点是不是比最远的节点要近   
			if (maxelem->dist_sq > dist_sq)
			{
				//如果是的话,就移除最远的节点   
				rheap_remove_max(heap);
				//并将此节点插入堆中   
				if (rheap_insert(heap, node, dist_sq) == -1)
				{
					return -1;
				}
				added_res = 1;

				range_sq = dist_sq;
			}
		}
		//如果堆的大小小于num,直接将此节点插入堆中   
		else
		{
			if (rheap_insert(heap, node, dist_sq) == -1)
			{
				return = 1;
			}
			added_res = 1;
		}
	}


	/* find signed distance from the splitting plane */
	dx = pos[node->dir] - node->pos[node->dir];

	ret = find_nearest_n(dx <= 0.0 ? node->left : node->right, pos, range, num, heap, dim);
	if (ret >= 0 && fabs(dx) < range) {
		added_res += ret;
		ret = find_nearest_n(dx <= 0.0 ? node->right : node->left, pos, range, num, heap, dim);
	}
}
#endif   


static void kd_nearest_i(kd_node_s *node, const float *pos, kd_node_s **result, float *result_dist_sq, kd_hyper_rect_s *rect)
{
	int dir = node->dir;
	int i;
	float dummy, dist_sq;
	kd_node_s *nearer_subtree, *farther_subtree;
	float *nearer_hyperrect_coord, *farther_hyperrect_coord;

	/* Decide whether to go left or right in the tree */
	dummy = pos[dir] - node->pos[dir];
	if (dummy <= 0)
	{
		nearer_subtree = node->left;
		farther_subtree = node->right;
		nearer_hyperrect_coord = rect->max + dir;
		farther_hyperrect_coord = rect->min + dir;
	}
	else
	{
		nearer_subtree = node->right;
		farther_subtree = node->left;
		nearer_hyperrect_coord = rect->min + dir;
		farther_hyperrect_coord = rect->max + dir;
	}

	if (nearer_subtree)
	{
		/* Slice the hyperrect to get the hyperrect of the nearer subtree */
		dummy = *nearer_hyperrect_coord;
		*nearer_hyperrect_coord = node->pos[dir];
		/* Recurse down into nearer subtree */
		kd_nearest_i(nearer_subtree, pos, result, result_dist_sq, rect);
		/* Undo the slice */
		*nearer_hyperrect_coord = dummy;
	}

	/* Check the distance of the point at the current node, compare it
	* with our best so far */
	dist_sq = 0;
	for (i = 0; i < rect->dim; i++)
	{
		dist_sq += SQ(node->pos[i] - pos[i]);
	}
	if (dist_sq < *result_dist_sq)
	{
		*result = node;
		*result_dist_sq = dist_sq;
	}

	if (farther_subtree) {
		/* Get the hyperrect of the farther subtree */
		dummy = *farther_hyperrect_coord;
		*farther_hyperrect_coord = node->pos[dir];
		/* Check if we have to recurse down by calculating the closest
		* point of the hyperrect and see if it's closer than our
		* minimum distance in result_dist_sq. */
		if (hyperrect_dist_sq(rect, pos) < *result_dist_sq) {
			/* Recurse down into farther subtree */
			kd_nearest_i(farther_subtree, pos, result, result_dist_sq, rect);
		}
		/* Undo the slice on the hyperrect */
		*farther_hyperrect_coord = dummy;
	}
}

//求kdtree中与点pos最近邻的值   
kd_result_s *kd_nearest(kd_tree_s *kd, const float *pos)
{
	kd_hyper_rect_s *rect;
	kd_node_s *result;
	kd_result_s *rset;
	float dist_sq;
	int i;

	//如果kd不存在,或者其超平面不存在的话,则就不会有结果   
	if (!kd) return 0;
	if (!kd->rect) return 0;

	/* Allocate result set */
	//为返回结果集合分配空间   
	if (!(rset = (kd_result_s *)malloc(sizeof *rset)))
	{
		return 0;
	}
	if (!(rset->rlist = (result_node_s *)alloc_resnode())) {
		free(rset);
		return 0;
	}
	rset->rlist->next = 0;
	rset->tree = kd;

	/* Duplicate the bounding hyperrectangle, we will work on the copy */
	//复制边界超平面   
	if (!(rect = hyperrect_duplicate(kd->rect)))
	{
		kd_res_free(rset);
		return 0;
	}

	/* Our first guesstimate is the root node */
	result = kd->root;
	dist_sq = 0;
	for (i = 0; i < kd->dim; i++)
		dist_sq += SQ(result->pos[i] - pos[i]);

	/* Search for the nearest neighbour recursively */
	//递归地查找最近邻的邻居   
	kd_nearest_i(kd->root, pos, &result, &dist_sq, rect);

	/* Free the copy of the hyperrect */
	//释放超矩形   
	hyperrect_free(rect);

	/* Store the result */
	//存储结果   
	if (result)
	{
		if (rlist_insert(rset->rlist, result, -1.0) == -1)
		{
			kd_res_free(rset);
			return 0;
		}
		rset->size = 1;
		kd_res_rewind(rset);
		return rset;
	}
	else
	{
		kd_res_free(rset);
		return 0;
	}
}

//kd_nearest的float特例   
kd_result_s *kd_nearestf(kd_tree_s *tree, const float *pos)
{
	static float sbuf[16];
	float *bptr, *buf = 0;
	int dim = tree->dim;
	kd_result_s *res;

	if (dim > 16) {
#ifndef NO_ALLOCA   
		if (dim <= 256)
			bptr = buf = (float*)alloca(dim * sizeof *bptr);
		else
#endif   
			if (!(bptr = buf = (float*)malloc(dim * sizeof *bptr))) {
				return 0;
			}
	}
	else {
		bptr = buf = sbuf;
	}

	while (dim-- > 0) {
		*bptr++ = *pos++;
	}

	res = kd_nearest(tree, buf);
#ifndef NO_ALLOCA   
	if (tree->dim > 256)
#else   
	if (tree->dim > 16)
#endif   
		free(buf);
	return res;
}

//kd_nearest的三坐标特例   
kd_result_s *kd_nearest3(kd_tree_s *tree, float x, float y, float z)
{
	float pos[3];
	pos[0] = x;
	pos[1] = y;
	pos[2] = z;
	return kd_nearest(tree, pos);
}

//kd_nearest的三坐标float特例   
kd_result_s *kd_nearest3f(kd_tree_s *tree, float x, float y, float z)
{
	float pos[3];
	pos[0] = x;
	pos[1] = y;
	pos[2] = z;
	return kd_nearest(tree, pos);
}

/* ---- nearest N search ---- */
/*
static kdres *kd_nearest_n(struct kdtree *kd, const float *pos, int num)
{
int ret;
struct kdres *rset;

if(!(rset = malloc(sizeof *rset))) {
return 0;
}
if(!(rset->rlist = alloc_resnode())) {
free(rset);
return 0;
}
rset->rlist->next = 0;
rset->tree = kd;

if((ret = find_nearest_n(kd->root, pos, range, num, rset->rlist, kd->dim)) == -1) {
kd_res_free(rset);
return 0;
}
rset->size = ret;
kd_res_rewind(rset);
return rset;
}*/

//找到满足距离小于range值的节点   
kd_result_s *kd_nearest_range(kd_tree_s *kd, const float *pos, float range)
{
	int ret;
	kd_result_s *rset;

	if (!(rset = (kd_result_s *)malloc(sizeof *rset))) {
		return 0;
	}
	if (!(rset->rlist = (result_node_s *)alloc_resnode())) {
		free(rset);
		return 0;
	}
	rset->rlist->next = 0;
	rset->tree = kd;

	if ((ret = find_nearest(kd->root, pos, range, rset->rlist, 0, kd->dim)) == -1) {
		kd_res_free(rset);
		return 0;
	}
	rset->size = ret;
	kd_res_rewind(rset);
	return rset;
}

//kd_nearest_range的float特例   
kd_result_s *kd_nearest_rangef(kd_tree_s *kd, const float *pos, float range)
{
	static float sbuf[16];
	float *bptr, *buf = 0;
	int dim = kd->dim;
	kd_result_s *res;

	if (dim > 16) {
#ifndef NO_ALLOCA   
		if (dim <= 256)
			bptr = buf = (float*)alloca(dim * sizeof *bptr);
		else
#endif   
			if (!(bptr = buf = (float*)malloc(dim * sizeof *bptr))) {
				return 0;
			}
	}
	else {
		bptr = buf = sbuf;
	}

	while (dim-- > 0) {
		*bptr++ = *pos++;
	}

	res = kd_nearest_range(kd, buf, range);
#ifndef NO_ALLOCA   
	if (kd->dim > 256)
#else   
	if (kd->dim > 16)
#endif   
		free(buf);
	return res;
}

//kd_nearest_range的三坐标特例   
kd_result_s *kd_nearest_range3(kd_tree_s *tree, float x, float y, float z, float range)
{
	float buf[3];
	buf[0] = x;
	buf[1] = y;
	buf[2] = z;
	return kd_nearest_range(tree, buf, range);
}

//kd_nearest_range的三坐标float特例   
kd_result_s *kd_nearest_range3f(kd_tree_s *tree, float x, float y, float z, float range)
{
	float buf[3];
	buf[0] = x;
	buf[1] = y;
	buf[2] = z;
	return kd_nearest_range(tree, buf, range);
}

//返回结果的释放   
void kd_res_free(kd_result_s *rset)
{
	clear_results(rset);
	free_resnode(rset->rlist);
	free(rset);
}

//获取返回结果集合的大小   
int kd_res_size(kd_result_s *set)
{
	return (set->size);
}

//再次回到这个节点本身的位置   
void kd_res_rewind(kd_result_s *rset)
{
	rset->riter = rset->rlist->next;
}

//找到返回结果中的最终节点   
int kd_res_end(kd_result_s *rset)
{
	return rset->riter == 0;
}

//返回结果列表中的下一个节点   
int kd_res_next(kd_result_s *rset)
{
	rset->riter = rset->riter->next;
	return rset->riter != 0;
}

//将返回结果的节点的坐标和data抽取出来   
void *kd_res_item(kd_result_s *rset, float *pos)
{
	if (rset->riter) {
		if (pos) {
			memcpy(pos, rset->riter->item->pos, rset->tree->dim * sizeof *pos);
		}
		return rset->riter->item->data;
	}
	return 0;
}

//将返回结果的节点的坐标和data抽取出来,坐标为float型的值   
void *kd_res_itemf(kd_result_s *rset, float *pos)
{
	if (rset->riter)
	{
		if (pos)
		{
			int i;
			for (i = 0; i<rset->tree->dim; i++) 
			{
				pos[i] = rset->riter->item->pos[i];
			}
		}
		return rset->riter->item->data;
	}
	return 0;
}

//将返回结果的节点的坐标和data抽取出来,坐标具体形式给出   
void *kd_res_item3(kd_result_s *rset, float *x, float *y, float *z)
{
	if (rset->riter) {
		if (*x)
		{
			*x = rset->riter->item->pos[0];
		}
		if (*y)
		{
			*y = rset->riter->item->pos[1];
		}
		if (*z)
		{
			*z = rset->riter->item->pos[2];
		}
	}
	return 0;
}

//将返回结果的节点的坐标和data抽取出来,坐标为float型的值,坐标具体形式给出   
void *kd_res_item3f(kd_result_s *rset, float *x, float *y, float *z)
{
	if (rset->riter)
	{
		if (*x)
		{
			*x = rset->riter->item->pos[0];
		}
		if (*y)
		{
			*y = rset->riter->item->pos[1];
		}
		if (*z)
		{
			*z = rset->riter->item->pos[2];
		}
	}
	return 0;
}

//获取data数据   
void *kd_res_item_data(kd_result_s *set)
{
	return kd_res_item(set, 0);
}

/* ---- hyperrectangle helpers ---- */
//创建超平面,包括三个参数:维度,每维的最小值和最大值数组   
static kd_hyper_rect_s *hyperrect_create(int dim, const float *min, const float *max)
{
	size_t size = dim * sizeof(float);
	kd_hyper_rect_s *rect = 0;

	if (!(rect = (kd_hyper_rect_s *)malloc(sizeof(kd_hyper_rect_s))))       //check check check check  !!!!!!!!!!!!!!!!!!!!!!
	{
		return 0;
	}

	rect->dim = dim;
	if (!(rect->min = (float*)malloc(size))) {
		free(rect);
		return 0;
	}
	if (!(rect->max = (float*)malloc(size))) {
		free(rect->min);
		free(rect);
		return 0;
	}
	memcpy(rect->min, min, size);
	memcpy(rect->max, max, size);

	return rect;
}

//释放超平面结构体   
static void hyperrect_free(kd_hyper_rect_s *rect)
{
	free(rect->min);
	free(rect->max);
	free(rect);
}

//赋值超平面结构体   
static kd_hyper_rect_s *hyperrect_duplicate(const kd_hyper_rect_s *rect)
{
	return hyperrect_create(rect->dim, rect->min, rect->max);
}

//更新超平面结构体最大\最小值数组   
static void hyperrect_extend(kd_hyper_rect_s *rect, const float *pos)
{
	int i;

	for (i = 0; i < rect->dim; i++)
	{
		if (pos[i] < rect->min[i]) 
		{
			rect->min[i] = pos[i];
		}
		if (pos[i] > rect->max[i]) 
		{
			rect->max[i] = pos[i];
		}
	}
}

//计算固定坐标点与超平面之间的距离   
static float hyperrect_dist_sq(kd_hyper_rect_s *rect, const float *pos)
{
	int i;
	float result = 0;

	for (i = 0; i < rect->dim; i++)
	{
		if (pos[i] < rect->min[i])
		{
			result += SQ(rect->min[i] - pos[i]);
		}
		else if (pos[i] > rect->max[i])
		{
			result += SQ(rect->max[i] - pos[i]);
		}
	}
	return result;
}


/* inserts the item. if dist_sq is >= 0, then do an ordered insert */
/* TODO make the ordering code use heapsort */
//函数参数: 返回结果节点指针,树节点指针,距离函数   
//将一个结果节点插入到返回结果的列表中   
static int rlist_insert(result_node_s *list, kd_node_s *item, float dist_sq)
{
	result_node_s *rnode;
	//创建一个返回结果的节点   
	if (!(rnode = (result_node_s *)alloc_resnode()))
	{
		return -1;
	}
	rnode->item = item;           //对应的树节点   
	rnode->dist_sq = dist_sq;     //对应的距离值   

								  //当距离大于零的时候   
	if (dist_sq >= 0.0)
	{
		while (list->next && list->next->dist_sq < dist_sq)
		{
			list = list->next;
		}
	}
	rnode->next = list->next;
	list->next = rnode;
	return 0;
}

//清除返回结果的集合   
//本质上是个双链表中单链表的清理   
static void clear_results(kd_result_s *rset)
{
	result_node_s *tmp, *node = rset->rlist->next;

	while (node)
	{
		tmp = node;
		node = node->next;
		free_resnode(tmp);
	}

	rset->rlist->next = 0;
}

void test_kd_tree()
{
	kd_tree_s tree;
	kd_tree_s *p = &tree;
	p = kd_create(10);
}